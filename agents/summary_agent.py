"""AI-powered summary generation for simulation results."""

import pandas as pd
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
import logging

logger = logging.getLogger(__name__)


class SummaryAgent:
    """AI agent that generates insightful summaries of simulation results."""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize summary agent with AI configuration."""
        self.config = config
        self.llm = ChatOpenAI(
            model_name=config.get('model', 'gpt-4'),
            temperature=0.3,  # Lower temperature for analytical writing
            request_timeout=config.get('timeout_seconds', 60)
        )
    
    async def generate_summary(self, 
                             market_log: List[Dict],
                             portfolio_ledger: pd.DataFrame,
                             banks: pd.DataFrame,
                             config: Dict) -> str:
        """Generate comprehensive summary of simulation results."""
        # Convert market log to DataFrame for analysis
        market_df = pd.DataFrame(market_log)
        
        # Analyze results
        analysis = self._analyze_results(market_df, portfolio_ledger, banks)
        
        # Build prompt with analysis
        prompt = self._build_summary_prompt(analysis, config)
        
        # Generate summary
        try:
            response = await self._get_llm_summary(prompt)
            
            # Add header and footer
            summary = f"""# Loan Market Simulation Summary

**Simulation Parameters:**
- Rounds: {config['simulation_params']['rounds']}
- Banks: {config['bank_params']['count']} ({config['bank_params']['strategy_split']['Grow']} Grow, {config['bank_params']['strategy_split']['Maintain']} Maintain)
- Consumers: {config['customer_params']['count']}
- Seed: {config['seed']}

---

{response}

---

*Generated by AI Summary Agent*
"""
            return summary
            
        except Exception as e:
            logger.error(f"Summary generation failed: {e}")
            return self._generate_fallback_summary(analysis)
    
    def _analyze_results(self, market_df: pd.DataFrame, 
                        portfolio_df: pd.DataFrame,
                        banks: pd.DataFrame) -> Dict:
        """Analyze simulation results for summary."""
        analysis = {}
        
        # Final state analysis
        final_round = market_df[market_df['round'] == market_df['round'].max()]
        
        # Bank performance by strategy
        for strategy in ['Grow', 'Maintain']:
            strategy_banks = final_round[final_round['strategy'] == strategy]
            
            analysis[f'{strategy}_performance'] = {
                'count': len(strategy_banks),
                'survived': len(strategy_banks[strategy_banks['bankrupt_flag'] == False]),
                'avg_final_equity': strategy_banks[strategy_banks['bankrupt_flag'] == False]['equity'].mean(),
                'avg_final_roe': strategy_banks[strategy_banks['bankrupt_flag'] == False]['ROE'].mean(),
                'total_profit': market_df[market_df['strategy'] == strategy]['profit'].sum()
            }
        
        # Market dynamics
        analysis['market_dynamics'] = {
            'avg_rate_trend': market_df.groupby('round')['offered_rate'].mean().tolist(),
            'total_volume_trend': market_df.groupby('round')['new_loan_volume'].sum().tolist(),
            'bankruptcy_timeline': market_df[market_df['bankrupt_flag'] == True].groupby('round').size().to_dict()
        }
        
        # Winners and losers
        cumulative_profits = market_df.groupby('bank_id')['profit'].sum().sort_values(ascending=False)
        analysis['top_performers'] = cumulative_profits.head(3).to_dict()
        analysis['bottom_performers'] = cumulative_profits.tail(3).to_dict()
        
        # Competition metrics
        market_concentration = market_df.groupby('round').apply(
            lambda x: (x['new_loan_volume'] / x['new_loan_volume'].sum()).pow(2).sum()
        )
        analysis['market_concentration'] = market_concentration.to_dict()
        
        return analysis
    
    def _build_summary_prompt(self, analysis: Dict, config: Dict) -> str:
        """Build prompt for summary generation."""
        prompt = f"""Analyze this loan market simulation and provide strategic insights.

SIMULATION RESULTS:

1. Strategy Performance:
- Grow Banks: {analysis['Grow_performance']['survived']}/{analysis['Grow_performance']['count']} survived
  - Average final equity: ${analysis['Grow_performance']['avg_final_equity']:,.0f}
  - Average final ROE: {analysis['Grow_performance']['avg_final_roe']:.1%}
  - Total cumulative profit: ${analysis['Grow_performance']['total_profit']:,.0f}

- Maintain Banks: {analysis['Maintain_performance']['survived']}/{analysis['Maintain_performance']['count']} survived
  - Average final equity: ${analysis['Maintain_performance']['avg_final_equity']:,.0f}
  - Average final ROE: {analysis['Maintain_performance']['avg_final_roe']:.1%}
  - Total cumulative profit: ${analysis['Maintain_performance']['total_profit']:,.0f}

2. Market Dynamics:
- Interest rate evolution: {analysis['market_dynamics']['avg_rate_trend']}
- Bankruptcy timeline: {analysis['market_dynamics']['bankruptcy_timeline']}

3. Top 3 Performers (Cumulative Profit):
{self._format_dict(analysis['top_performers'])}

4. Bottom 3 Performers (Cumulative Profit):
{self._format_dict(analysis['bottom_performers'])}

TASK: Write a strategic analysis covering:

1. **Strategy Comparison**: Which strategy (Grow vs Maintain) performed better and why? Consider both survival rates and profitability.

2. **Market Evolution**: How did the market evolve over the {config['simulation_params']['rounds']} rounds? Identify key phases and turning points.

3. **Competitive Dynamics**: What patterns emerged in bank competition? How did AI agents adapt their strategies?

4. **Success Factors**: What distinguished the top performers from those that struggled or went bankrupt?

5. **Key Insights**: What are the main lessons for bank executives? How should they balance growth vs profitability?

Focus on data-driven insights and actionable conclusions. Use specific numbers to support your analysis."""
        
        return prompt
    
    def _format_dict(self, d: Dict) -> str:
        """Format dictionary for prompt."""
        return '\n'.join([f"- {k}: ${v:,.0f}" for k, v in d.items()])
    
    async def _get_llm_summary(self, prompt: str) -> str:
        """Get summary from LLM."""
        messages = [
            SystemMessage(content="You are a financial analyst specializing in competitive market dynamics."),
            HumanMessage(content=prompt)
        ]
        
        response = await self.llm.agenerate([messages])
        return response.generations[0][0].text
    
    def _generate_fallback_summary(self, analysis: Dict) -> str:
        """Generate basic summary if AI fails."""
        return f"""## Analysis Results

### Strategy Performance
- **Grow Strategy**: {analysis['Grow_performance']['survived']}/{analysis['Grow_performance']['count']} banks survived
- **Maintain Strategy**: {analysis['Maintain_performance']['survived']}/{analysis['Maintain_performance']['count']} banks survived

### Market Outcomes
- Total bankruptcies: {sum(analysis['market_dynamics']['bankruptcy_timeline'].values())}
- Final market concentration: Varied throughout simulation

### Key Observations
- Interest rates showed dynamic competition
- Both strategies had mixed results
- Market reached various equilibrium states

*Note: This is a fallback summary due to AI generation failure.*"""