"""AI-powered summary generation for simulation results."""

import pandas as pd
from typing import Dict, Any, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
import logging

logger = logging.getLogger(__name__)


class SummaryAgent:
    """AI agent that generates insightful summaries of simulation results."""

    def __init__(self, config: Dict[str, Any]):
        """Initialize summary agent with AI configuration."""
        self.config = config
        try:
            self.llm = ChatOpenAI(
                model_name=config.get("model", "gpt-4"),
                temperature=0.3,  # Lower temperature for analytical writing
                request_timeout=config.get("timeout_seconds", 60),
            )
        except Exception as e:
            logger.error(f"Failed to initialize SummaryAgent LLM: {e}", exc_info=True)
            print(f"ERROR: Failed to initialize Summary AI agent: {e}")
            print(f"Check your OpenAI API key and model configuration: {config.get('model', 'gpt-4')}")
            raise

    async def generate_summary(
        self,
        market_log: List[Dict],
        portfolio_ledger: pd.DataFrame,
        banks: pd.DataFrame,
        config: Dict,
    ) -> str:
        """Generate comprehensive summary of simulation results."""
        # Convert market log to DataFrame for analysis
        market_df = pd.DataFrame(market_log)

        # Analyze results
        analysis = self._analyze_results(market_df, portfolio_ledger, banks)

        # Build prompt with analysis
        prompt = self._build_summary_prompt(analysis, config)

        # Generate summary
        try:
            response = await self._get_llm_summary(prompt)

            # Calculate strategy split from analysis
            grow_count = analysis['Grow_performance']['count']
            maintain_count = analysis['Maintain_performance']['count']
            
            # Add header and footer with all tables
            roe_table = self._format_roe_table(analysis["roe_table"])
            portfolio_table = self._format_portfolio_table(analysis["portfolio_table"])
            rates_table = self._format_rates_table(analysis["rates_table"])
            profit_table = self._format_profit_table(analysis["profit_table"])
            equity_table = self._format_equity_table(analysis["equity_table"])
            summary = f"""# Loan Market Simulation Summary

**Simulation Parameters:**
- Rounds: {config['simulation_params']['rounds']}
- Banks: {config['bank_params']['count']} ({grow_count} Grow, {maintain_count} Maintain)
- Consumers: {config['customer_params']['count']}
- Seed: {config['seed']}

---

{response}

---

## ROE by Round (%)

{roe_table}

---

## Interest Rates by Round (bps)

{rates_table}

---

## Profit by Round ($M)

{profit_table}

---

## Portfolio Balance by Round ($M)

{portfolio_table}

---

## Equity by Round ($M)

{equity_table}

---

*Generated by AI Summary Agent*
"""
            return summary

        except Exception as e:
            logger.error(f"Summary generation failed: {e}", exc_info=True)
            print(f"WARNING: AI summary generation failed: {e}")
            print("Using fallback summary. Check logs for full error details.")
            return self._generate_fallback_summary(analysis, str(e))

    def _analyze_results(
        self, market_df: pd.DataFrame, portfolio_df: pd.DataFrame, banks: pd.DataFrame
    ) -> Dict:
        """Analyze simulation results for summary."""
        analysis = {}

        # Final state analysis
        final_round = market_df[market_df["round"] == market_df["round"].max()]

        # Bank performance by strategy
        for strategy in ["Grow", "Maintain"]:
            strategy_banks = final_round[final_round["strategy"] == strategy]

            analysis[f"{strategy}_performance"] = {
                "count": len(strategy_banks),
                "survived": len(
                    strategy_banks[strategy_banks["bankrupt_flag"] == False]
                ),
                "avg_final_equity": strategy_banks[
                    strategy_banks["bankrupt_flag"] == False
                ]["equity"].mean(),
                "avg_final_roe": strategy_banks[
                    strategy_banks["bankrupt_flag"] == False
                ]["ROE"].mean(),
                "total_profit": market_df[market_df["strategy"] == strategy][
                    "profit"
                ].sum(),
            }

        # Market dynamics
        analysis["market_dynamics"] = {
            "avg_rate_trend": market_df.groupby("round")["offered_rate"]
            .mean()
            .tolist(),
            "total_volume_trend": market_df.groupby("round")["new_loan_volume"]
            .sum()
            .tolist(),
            "bankruptcy_timeline": market_df[market_df["bankrupt_flag"] == True]
            .groupby("round")
            .size()
            .to_dict(),
        }

        # Winners and losers
        cumulative_profits = (
            market_df.groupby("bank_id")["profit"].sum().sort_values(ascending=False)
        )
        analysis["top_performers"] = cumulative_profits.head(3).to_dict()
        analysis["bottom_performers"] = cumulative_profits.tail(3).to_dict()

        # Competition metrics
        market_concentration = market_df.groupby("round").apply(
            lambda x: (x["new_loan_volume"] / x["new_loan_volume"].sum()).pow(2).sum()
        )
        analysis["market_concentration"] = market_concentration.to_dict()

        # ROE table (rounds x banks)
        roe_pivot = market_df.pivot(index="round", columns="bank_id", values="ROE")
        analysis["roe_table"] = roe_pivot.to_dict()

        # Portfolio balance table (rounds x banks) - using portfolio_balance_start
        portfolio_pivot = market_df.pivot(index="round", columns="bank_id", values="portfolio_balance_start")
        analysis["portfolio_table"] = portfolio_pivot.to_dict()

        # Interest rates table (rounds x banks)
        rates_pivot = market_df.pivot(index="round", columns="bank_id", values="offered_rate")
        analysis["rates_table"] = rates_pivot.to_dict()

        # Profit table (rounds x banks)
        profit_pivot = market_df.pivot(index="round", columns="bank_id", values="profit")
        analysis["profit_table"] = profit_pivot.to_dict()

        # Equity table (rounds x banks)
        equity_pivot = market_df.pivot(index="round", columns="bank_id", values="equity")
        analysis["equity_table"] = equity_pivot.to_dict()

        return analysis

    def _build_summary_prompt(self, analysis: Dict, config: Dict) -> str:
        """Build prompt for summary generation."""
        prompt = f"""Analyze this loan market simulation and provide strategic insights.

SIMULATION RESULTS:

1. Strategy Performance:
- Grow Banks: {analysis['Grow_performance']['survived']}/{analysis['Grow_performance']['count']} survived
  - Average final equity: ${analysis['Grow_performance']['avg_final_equity']:,.0f}
  - Average final ROE: {analysis['Grow_performance']['avg_final_roe']:.1%}
  - Total cumulative profit: ${analysis['Grow_performance']['total_profit']:,.0f}

- Maintain Banks: {analysis['Maintain_performance']['survived']}/{analysis['Maintain_performance']['count']} survived
  - Average final equity: ${analysis['Maintain_performance']['avg_final_equity']:,.0f}
  - Average final ROE: {analysis['Maintain_performance']['avg_final_roe']:.1%}
  - Total cumulative profit: ${analysis['Maintain_performance']['total_profit']:,.0f}

2. Market Dynamics:
- Interest rate evolution: {analysis['market_dynamics']['avg_rate_trend']}
- Bankruptcy timeline: {analysis['market_dynamics']['bankruptcy_timeline']}

3. Top 3 Performers (Cumulative Profit):
{self._format_dict(analysis['top_performers'])}

4. Bottom 3 Performers (Cumulative Profit):
{self._format_dict(analysis['bottom_performers'])}

TASK: Write a strategic analysis covering:

1. **Strategy Comparison**: Which strategy (Grow vs Maintain) performed better and why? Consider both survival rates and profitability.

2. **Market Evolution**: How did the market evolve over the {config['simulation_params']['rounds']} rounds? Identify key phases and turning points.

3. **Competitive Dynamics**: What patterns emerged in bank competition? How did AI agents adapt their strategies?

4. **Success Factors**: What distinguished the top performers from those that struggled or went bankrupt?

5. **Key Insights**: What are the main lessons for bank executives? How should they balance growth vs profitability?

Focus on data-driven insights and actionable conclusions. Use specific numbers to support your analysis."""

        return prompt

    def _format_dict(self, d: Dict) -> str:
        """Format dictionary for prompt."""
        return "\n".join([f"- {k}: ${v:,.0f}" for k, v in d.items()])

    def _format_roe_table(self, roe_data: Dict) -> str:
        """Format ROE table for display."""
        # roe_data is structured as {bank_id: {round: roe_value}}
        if not roe_data:
            return "No ROE data available"
        
        # Get all banks and rounds
        banks = sorted(roe_data.keys())
        rounds = sorted(set().union(*(roe_data[bank].keys() for bank in banks)))
        
        # Build table
        lines = []
        
        # Header row
        header = "| Round |" + "".join([f" {bank} |" for bank in banks])
        lines.append(header)
        
        # Separator row
        separator = "|-------|" + "".join([f"------|" for _ in banks])
        lines.append(separator)
        
        # Data rows
        for round_num in rounds:
            row = f"| {round_num:5d} |"
            for bank in banks:
                roe_val = roe_data[bank].get(round_num, 0.0)
                if roe_val == 0.0:
                    row += f"  0.0% |"
                else:
                    row += f" {roe_val:4.1%} |"
            lines.append(row)
        
        return "\n".join(lines)

    def _format_portfolio_table(self, portfolio_data: Dict) -> str:
        """Format Portfolio Balance table for display."""
        # portfolio_data is structured as {bank_id: {round: portfolio_value}}
        if not portfolio_data:
            return "No portfolio data available"
        
        # Get all banks and rounds
        banks = sorted(portfolio_data.keys())
        rounds = sorted(set().union(*(portfolio_data[bank].keys() for bank in banks)))
        
        # Build table
        lines = []
        
        # Header row
        header = "| Round |" + "".join([f" {bank} |" for bank in banks])
        lines.append(header)
        
        # Separator row
        separator = "|-------|" + "".join([f"------|" for _ in banks])
        lines.append(separator)
        
        # Data rows
        for round_num in rounds:
            row = f"| {round_num:5d} |"
            for bank in banks:
                portfolio_val = portfolio_data[bank].get(round_num, 0.0)
                if portfolio_val == 0.0:
                    row += f"  $0.0 |"
                else:
                    # Convert to millions and format
                    portfolio_millions = portfolio_val / 1_000_000
                    row += f" ${portfolio_millions:4.1f} |"
            lines.append(row)
        
        return "\n".join(lines)

    def _format_rates_table(self, rates_data: Dict) -> str:
        """Format Interest Rates table for display."""
        # rates_data is structured as {bank_id: {round: rate_value}}
        if not rates_data:
            return "No rates data available"
        
        # Get all banks and rounds
        banks = sorted(rates_data.keys())
        rounds = sorted(set().union(*(rates_data[bank].keys() for bank in banks)))
        
        # Build table
        lines = []
        
        # Header row
        header = "| Round |" + "".join([f" {bank} |" for bank in banks])
        lines.append(header)
        
        # Separator row
        separator = "|-------|" + "".join([f"------|" for _ in banks])
        lines.append(separator)
        
        # Data rows
        for round_num in rounds:
            row = f"| {round_num:5d} |"
            for bank in banks:
                rate_val = rates_data[bank].get(round_num, 0)
                if rate_val == 0:
                    row += f"   0 |"
                else:
                    row += f" {rate_val:3.0f} |"
            lines.append(row)
        
        return "\n".join(lines)

    def _format_profit_table(self, profit_data: Dict) -> str:
        """Format Profit table for display."""
        # profit_data is structured as {bank_id: {round: profit_value}}
        if not profit_data:
            return "No profit data available"
        
        # Get all banks and rounds
        banks = sorted(profit_data.keys())
        rounds = sorted(set().union(*(profit_data[bank].keys() for bank in banks)))
        
        # Build table
        lines = []
        
        # Header row
        header = "| Round |" + "".join([f" {bank} |" for bank in banks])
        lines.append(header)
        
        # Separator row
        separator = "|-------|" + "".join([f"------|" for _ in banks])
        lines.append(separator)
        
        # Data rows
        for round_num in rounds:
            row = f"| {round_num:5d} |"
            for bank in banks:
                profit_val = profit_data[bank].get(round_num, 0.0)
                if profit_val == 0.0:
                    row += f"  $0.0 |"
                else:
                    # Convert to millions and format
                    profit_millions = profit_val / 1_000_000
                    if profit_millions >= 0:
                        row += f" ${profit_millions:4.1f} |"
                    else:
                        row += f"${profit_millions:5.1f} |"
            lines.append(row)
        
        return "\n".join(lines)

    def _format_equity_table(self, equity_data: Dict) -> str:
        """Format Equity table for display."""
        # equity_data is structured as {bank_id: {round: equity_value}}
        if not equity_data:
            return "No equity data available"
        
        # Get all banks and rounds
        banks = sorted(equity_data.keys())
        rounds = sorted(set().union(*(equity_data[bank].keys() for bank in banks)))
        
        # Build table
        lines = []
        
        # Header row
        header = "| Round |" + "".join([f" {bank} |" for bank in banks])
        lines.append(header)
        
        # Separator row
        separator = "|-------|" + "".join([f"------|" for _ in banks])
        lines.append(separator)
        
        # Data rows
        for round_num in rounds:
            row = f"| {round_num:5d} |"
            for bank in banks:
                equity_val = equity_data[bank].get(round_num, 0.0)
                if equity_val == 0.0:
                    row += f"  $0.0 |"
                else:
                    # Convert to millions and format
                    equity_millions = equity_val / 1_000_000
                    if equity_millions >= 0:
                        row += f" ${equity_millions:4.1f} |"
                    else:
                        row += f"${equity_millions:5.1f} |"
            lines.append(row)
        
        return "\n".join(lines)

    async def _get_llm_summary(self, prompt: str) -> str:
        """Get summary from LLM."""
        messages = [
            SystemMessage(
                content="You are a financial analyst specializing in competitive market dynamics."
            ),
            HumanMessage(content=prompt),
        ]

        response = await self.llm.agenerate([messages])
        return response.generations[0][0].text

    def _generate_fallback_summary(self, analysis: Dict, error_msg: str = "Unknown error") -> str:
        """Generate basic summary if AI fails."""
        roe_table = self._format_roe_table(analysis.get("roe_table", {}))
        portfolio_table = self._format_portfolio_table(analysis.get("portfolio_table", {}))
        rates_table = self._format_rates_table(analysis.get("rates_table", {}))
        profit_table = self._format_profit_table(analysis.get("profit_table", {}))
        equity_table = self._format_equity_table(analysis.get("equity_table", {}))
        return f"""## Analysis Results

### Strategy Performance
- **Grow Strategy**: {analysis['Grow_performance']['survived']}/{analysis['Grow_performance']['count']} banks survived
- **Maintain Strategy**: {analysis['Maintain_performance']['survived']}/{analysis['Maintain_performance']['count']} banks survived

### Market Outcomes
- Total bankruptcies: {sum(analysis['market_dynamics']['bankruptcy_timeline'].values())}
- Final market concentration: Varied throughout simulation

### Key Observations
- Interest rates showed dynamic competition
- Both strategies had mixed results
- Market reached various equilibrium states

---

## ROE by Round (%)

{roe_table}

---

## Interest Rates by Round (bps)

{rates_table}

---

## Profit by Round ($M)

{profit_table}

---

## Portfolio Balance by Round ($M)

{portfolio_table}

---

## Equity by Round ($M)

{equity_table}

---

**WARNING: AI GENERATION FAILED**
Error: {error_msg}

*This is a fallback summary. The AI summary agent failed to generate the full analysis.*
*Check the simulation logs for detailed error information.*"""
